---
title: "Pertemuan 1 - Pemulusan"
author: Jonathan Marjono (G1401211064)
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Pendahuluan

Pada bagian ini akan dijelaskan data yang akan digunakan, pembersihan data, serta referensi sumber dari data tersebut.

### 1.1 Penjelasan terhadap data (dt.set)

Data yang digunakan berasal dari tabel data produksi bulanan perkebunan besar dalam satuan ton. Pada data tersebut terdapat beberapa jenis tanaman perkebunan besar diantaranya adalah karet kering, minyak sawit, biji sawit, coklat, kopi, teh, kulit kina, gula tebu, serta tembakau. Data tersebut tercatat produksinya dengan periode bulanan, yakni produksi bulan januari, produksi bulan februari, dan seterusnya dalam setiap satu tahunnya.

Data yang akan dipakai adalah data produksi bulanan untuk tanaman perkebunan karet sawit mulai dari tahun 2019 hingga 2018. Pada data tersebut akan diambil setiap bulannya selama 10 tahun, sehingga didapatkan: 10 tahun x 12 bulan = 120 periode data produksi karet kering.

### 1.2 Pengambilan dan pengolahan data

Sebelum dianalisis menggunakan bantuan R dengan interface RStudio, maka data terlebih dahulu dirapihkan pada Excel dan disimpan pada github dengan format data csv.

### 1.3 Referensi sumber data

Berikut ini merupakan referensi tabel seutuhnya (penuh) yang digunakan.

Tahun 2009: <https://www.bps.go.id/indicator/54/761/10/produksi-bulanan-perkebunan-besar.html>

Tahun 2010: <https://www.bps.go.id/indicator/54/761/9/produksi-bulanan-perkebunan-besar.html>

Tahun 2011: <https://www.bps.go.id/indicator/54/761/8/produksi-bulanan-perkebunan-besar.html>

Tahun 2012: <https://www.bps.go.id/indicator/54/761/7/produksi-bulanan-perkebunan-besar.html>

Tahun 2013: <https://www.bps.go.id/indicator/54/761/6/produksi-bulanan-perkebunan-besar.html>

Tahun 2014: <https://www.bps.go.id/indicator/54/761/5/produksi-bulanan-perkebunan-besar.html>

Tahun 2015: <https://www.bps.go.id/indicator/54/761/4/produksi-bulanan-perkebunan-besar.html>

Tahun 2016: <https://www.bps.go.id/indicator/54/761/3/produksi-bulanan-perkebunan-besar.html>

Tahun 2017: <https://www.bps.go.id/indicator/54/761/2/produksi-bulanan-perkebunan-besar.html>

Tahun 2018: <https://www.bps.go.id/indicator/54/761/1/produksi-bulanan-perkebunan-besar.html>

## 2. Library / Packages

### 2.1 Menginstall packages

*Package* R yang akan digunakan untuk tugas praktikum pekan pertama dari mata kuliah Metode Peramalan Deret Waktu (MPDW) adalah: `forecast`, `graphics`, `TTR`, `TSA` . Jika *packages* tersebut belum tersedia, maka dilakukan tahap penginstallan terlebih dahulu.

```{r}
#install.packages("forecast")
#install.packages("graphics")
#install.packages("TTR")
#install.packages("TSA")
```

### 2.2 Menjalankan package tersebut

Jika *packages* tersebut sudah ada, maka akan dipanggil library *package* tersebut.

```{r}
library("forecast")
library("graphics")
library("TTR")
library("TSA")
```

## 3. Impor Data

### 3.1 Package "rio"

Menginstall *package* library rio terlebih dahulu sebelum digunakan apabila belum tersedia.

```{r}
#install.packages("rio")
```

### 3.2 Memasukkan data kedalam dt.set

Memasukkan data yang akan digunakan berbentuk csv dari link github yang tersedia.

```{r}
library(rio)
dt.set <- import("https://raw.githubusercontent.com/jonathanmarjonoxz/MPDW/main/Responsi1/Data_ProduksiKaretKering.csv")
```

## 4. Eksplorasi Data

Melihat data menggunakan fungsi `View()`, struktur data menggunakan fungsi `str()`, dan dimensi data menggunakan fungsi `dim()`.

```{r}
View(dt.set)
str(dt.set)
dim(dt.set)
```

Mengubah data agar terbaca sebagai data deret waktu dengan fungsi `ts()`.

```{r}
dt.set.ts <- ts(dt.set$`Produksi Karet Kering`)
```

Menampilkan ringkasan data.

Berikut hasil ringkasan datanya, dengan nilai terkecil 31.00, kuartil1 40.15, median 45.52, mean 48.24, serta kuartil3 51.88, dan maksimum data 85.09.

```{r}
summary(dt.set.ts)
```

Membuat plot data deret waktu, saat plot dibuat terlihat ada sedikit perbedaan pola data dari periode data ke 1-60 dengan periode data ke 61-120.

```{r}
ts.plot(dt.set.ts, xlab="Time Period", ylab="Produksi Karet Kering (Ton)", 
        main = "Time Series Plot")
points(dt.set.ts)
```

Melihat plot data deret waktu dengan lebih detail dengan cara memberikan sebuah pembatasan dengan batas masing-masing 60 data pada dt.set yang dimiliki, sehingga dibagi 50% pada data deretwaktu, serta 50% sisanya pada data deretwaktu2.

```{r}
deretwaktu <- dt.set[1:60,]
deretwaktu2 <- dt.set[61:120,]
deretwaktu.ts <- ts(deretwaktu$`Produksi Karet Kering`)
deretwaktu2.ts <- ts(deretwaktu2$`Produksi Karet Kering`)
```

Kemudian dibuat plot dari data deretwaktu, sehingga terlihat pada plot ini data terlihat mengikuti pola trend.

```{r}
ts.plot(deretwaktu.ts, xlab="Time Period", ylab="Produksi Karet Kering (Ton)", 
        main = "Time Series Plot")
points(deretwaktu.ts)
```

Serta dibuat plot dari data deretwaktu2. Namun, pada data deretwaktu2 terlihat data serupa mengikuti pola musiman.

```{r}
ts.plot(deretwaktu2.ts, xlab="Time Period", ylab="Produksi Karet Kering (Ton)", 
        main = "Time Series Plot")
points(deretwaktu2.ts)
```

Sehingga akan dicoba secara lebih detail untuk pemulusan analisis deret waktu yang memiliki pola data trend serta pola musiman, namun dalam analisis kali ini data tetap tidak akan dipisah, melainkan dengan memanfaatkan 80% data untuk meramal serta 20% data yang diramal (yang dilakukan forecast).

## 5. Single Moving Average & Double Moving Average

### 5.1 Pembagian data

Pembagian data menjadi dua dari dt.set, sehingga dibagi ke dalam dt.ramal dan dt.uji yang dilakukan dengan perbandingan 80% dt.ramal dan 20% dt.uji.

```{r}
brapadtramal = (80/100)*nrow(dt.set)
brapadtramal
brapadtuji = (20/100)*nrow(dt.set)
brapadtuji
```

Berdasarkan perhitungan dengan rumus di atas diperoleh sebanyak **96** periode untuk data ramal serta **24** periode untuk data uji. Oleh karena itu data ramal akan diambil dari baris **1-96** pada dt.set, serta data uji akan menggunakan baris berikutnya yakni **97-120** pada dt.set.

Berikut sedikit penjelasan untuk penamaannya:

data ramal = dt.ramal = dt.forecast = data yang dimilki untuk meramal.

data uji = dt.uji = dt.test = data yang akan diramal.

```{r}
#Membagi data dt.ramal dan dt.uji dengan 80% dan 20%
dt.ramal_ma <- dt.set[1:96,] #Periode 1-96
dt.uji_ma <- dt.set[97:120,] #Periode 97-120
#Mengubah agar terbaca sebagai data deret waktu
dt.ramal_ma.ts <- ts(dt.ramal_ma$`Produksi Karet Kering`)
dt.uji_ma.ts <- ts(dt.uji_ma$`Produksi Karet Kering`)
```

### 5.2 Eksplorasi data

Eksplorasi data dilakukan pada keseluruhan data dt.set, dt.ramal, serta dt.uji menggunakan plot data deret waktu.

```{r}
#Eksplorasi pada keseluruhan data
plot(dt.set.ts, col="orchid",main="Plot Semua Data")
points(dt.set.ts)

#Eksplorasi dt.ramal (periode 1-96)
plot(dt.ramal_ma.ts, col="dodgerblue4",main="Plot Data Ramal")
points(dt.ramal_ma.ts)

#Eksplorasi dt.uji (periode 97-120)
plot(dt.uji_ma.ts, col="dodgerblue4",main="Plot Data Uji")
points(dt.uji_ma.ts)
```

Eksplorasi data juga dapat dilakukan menggunakan package `ggplot2` dengan terlebih dahulu memanggil library *package* `ggplot2`.

```{r}
#Eksplorasi dengan package GGPLOT
library(ggplot2)
ggplot() + 
  geom_line(data = dt.ramal_ma, aes(x = Periode, y =`Produksi Karet Kering`, col = "Data Ramal")) +
  geom_line(data = dt.uji_ma, aes(x = Periode, y =`Produksi Karet Kering`, col = "Data Uji")) +
  labs(x = "Periode Waktu", y = "Produksi Karet Kering", color = "Legend") +
  scale_colour_manual(name="Keterangan:", breaks = c("Data Ramal", "Data Uji"),
                      values = c("royalblue", "red2")) + 
  theme_bw() + theme(legend.position = "bottom",
                     plot.caption = element_text(hjust=0.5, size=12))
```

### 5.3 Single Moving Average (SMA)

#### 5.3.1 Penjelasan SMA

Ide dasar dari Single Moving Average (SMA) adalah data suatu periode dipengaruhi oleh data periode sebelumnya. Metode pemulusan ini cocok digunakan untuk pola **data stasioner atau konstan**. Prinsip dasar metode pemulusan ini adalah data pemulusan pada periode ke-t merupakan rata rata dari m buah data pada periode ke-t hingga periode ke (t-m+1). Data pemulusan pada periode ke-t selanjutnya digunakan sebagai nilai peramalan pada periode ke t+1.

#### 5.3.2 Melakukan SMA dengan parameter m=4

Pemulusan menggunakan metode SMA dilakukan dengan fungsi `SMA()`. Dalam hal ini akan dilakukan pemulusan dengan parameter `m=4`.

```{r}
data.sma<-SMA(dt.ramal_ma.ts, n=4)
data.sma
```

Data pemulusan pada periode ke-t selanjutnya digunakan sebagai nilai peramalan pada periode ke t+1 sehingga hasil peramalan 1 periode kedepan adalah sebagai berikut.

```{r}
data.ramal<-c(NA,data.sma)
data.ramal #forecast 1 periode ke depan
```

Selanjutnya akan dilakukan peramalan sejumlah data uji yaitu 24 periode. Pada metode SMA, hasil peramalan 24 periode ke depan akan bernilai sama dengan hasil peramalan 1 periode kedepan. Dalam hal ini akan dilakukan penggabungan data aktual dt.ramal, data hasil pemulusan dan data hasil ramalan 24 periode kedepan.

```{r}
data.gab<-cbind(aktual=c(dt.ramal_ma.ts,rep(NA,24)),pemulusan=c(data.sma,rep(NA,24)),ramalan=c(data.ramal,rep(data.ramal[length(data.ramal)],23)))
data.gab #forecast 24 periode ke depan
```

#### 5.3.3 Plot hasil SMA

Adapun plot data deret waktu dari hasil peramalan yang dilakukan adalah sebagai berikut. Sehingga dapat dilihat plot dari data aktual (warna hitam), data pemulusan (warna biru), serta data peramalan (warna merah) dengan menggunakan parameter m=4.

```{r}
ts.plot(dt.set.ts, xlab="Time Period", ylab="Produksi Karet Kering", main= "SMA N=4 Data Produksi Karet Kering")
points(dt.set.ts)
lines(data.gab[,2],col="cyan4",lwd=2)
lines(data.gab[,3],col="red2",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","cyan4","red2"), cex=0.5)
```

#### 5.3.4 Akurasi data ramal

Selanjutnya perhitungan akurasi dilakukan dengan ukuran akurasi *Sum Squares Error* (SSE), *Mean Square Error* (MSE) dan *Mean Absolute Percentage Error* (MAPE). Perhitungan akurasi dilakukan baik pada dt.ramal maupun pada dt.uji.

```{r}
#Menghitung nilai keakuratan dt.ramal
error_dt.ramal.sma = dt.ramal_ma.ts-data.ramal[1:length(dt.ramal_ma.ts)]
SSE_dt.ramal.sma = sum(error_dt.ramal.sma[5:length(dt.ramal_ma.ts)]^2)
MSE_dt.ramal.sma = mean(error_dt.ramal.sma[5:length(dt.ramal_ma.ts)]^2)
MAPE_dt.ramal.sma = mean(abs((error_dt.ramal.sma[5:length(dt.ramal_ma.ts)]/dt.ramal_ma.ts[5:length(dt.ramal_ma.ts)])*100))

akurasi_dt.ramal.sma <- matrix(c(SSE_dt.ramal.sma, MSE_dt.ramal.sma, MAPE_dt.ramal.sma))
row.names(akurasi_dt.ramal.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_dt.ramal.sma) <- c("Akurasi m = 4")
akurasi_dt.ramal.sma
```

Dalam hal ini diperoleh nilai MAPE dari dt.ramal pada metode pemulusan SMA sebesar 15.61, karena cukup besar sehingga dapat dikatakan nilai ini memberikan nilai akurasi yang kurang baik. Selanjutnya dilakukan perhitungan nilai MAPE dt.uji pada metode pemulusan SMA.

#### 5.3.5 Akurasi data uji

```{r}
#Menghitung nilai keakuratan dt.uji
error_dt.uji.sma = dt.uji_ma.ts-data.gab[97:120,3]
SSE_dt.uji.sma = sum(error_dt.uji.sma^2)
MSE_dt.uji.sma = mean(error_dt.uji.sma^2)
MAPE_dt.uji.sma = mean(abs((error_dt.uji.sma/dt.uji_ma.ts*100)))

akurasi_dt.uji.sma <- matrix(c(SSE_dt.uji.sma, MSE_dt.uji.sma, MAPE_dt.uji.sma))
row.names(akurasi_dt.uji.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_dt.uji.sma) <- c("Akurasi m = 4")
akurasi_dt.uji.sma
```

Perhitungan akurasi menggunakan dt.uji menghasilkan nilai MAPE yang besar yakni 69.76, sehingga memiliki nilai akurasi yang kurang baik.

#### 5.3.6 Kesimpulan dari SMA

```{r}
library(kableExtra)
tabelSMA<-cbind(MAPE_dt.ramal.sma,MAPE_dt.uji.sma)
kable(tabelSMA,caption="Tabel Akurasi Metode SMA")
```

Karena tidak ditemukan hasil peramalan yang akurat dengan SMA, maka dapat dikatakan pemanfaatkan SMA kurang ideal untuk dijadikan sebagai pemulusan dari data tersebut, oleh karena itu akan dicoba cara pemulusan lainnya yang lebih sesuai.

### 5.4 Double Moving Average (DMA)

#### 5.4.1 Penjelasan DMA

Metode pemulusan Double Moving Average (DMA) pada dasarnya mirip dengan SMA. Namun demikian, metode ini lebih cocok digunakan untuk **pola data trend**. Proses pemulusan dengan rata rata dalam metode ini dilakukan sebanyak 2 kali.

#### 5.4.2 Melakukan DMA dengan parameter m=4

```{r}
dma <- SMA(data.sma, n = 4)
At <- 2*data.sma - dma
Bt <- 2/(4-1)*(data.sma - dma)
data.dma<- At+Bt
data.ramal2<- c(NA, data.dma)

t = 1:24
f = c()

for (i in t) {
  f[i] = At[length(At)] + Bt[length(Bt)]*(i)
}

data.gab2 <- cbind(aktual = c(dt.ramal_ma.ts,rep(NA,24)), pemulusan1 = c(data.sma,rep(NA,24)),pemulusan2 = c(data.dma, rep(NA,24)),At = c(At, rep(NA,24)), Bt = c(Bt,rep(NA,24)),ramalan = c(data.ramal2, f[-1]))
data.gab2
```

#### 5.4.3 Plot hasil DMA

Hasil pemulusan menggunakan metode DMA divisualisasikan sebagai berikut.

```{r}
ts.plot(dt.set.ts, xlab="Time Period", ylab="Produksi Karet Kering", main= "DMA N=4 Data Produksi Karet Kering")
points(dt.set.ts)
lines(data.gab2[,3],col="cyan4",lwd=2)
lines(data.gab2[,6],col="red2",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","cyan4","red2"), cex=0.8)
```

#### 5.4.4 Akurasi data ramal

Selanjutnya perhitungan akurasi dilakukan baik pada dt.ramal maupun dt.uji. Perhitungan akurasi dilakukan dengan ukuran akurasi SSE, MSE dan MAPE.

```{r}
#Menghitung nilai keakuratan dt.ramal
error_dt.ramal.dma = dt.ramal_ma.ts-data.ramal2[1:length(dt.ramal_ma.ts)]
SSE_dt.ramal.dma = sum(error_dt.ramal.dma[8:length(dt.ramal_ma.ts)]^2)
MSE_dt.ramal.dma = mean(error_dt.ramal.dma[8:length(dt.ramal_ma.ts)]^2)
MAPE_dt.ramal.dma = mean(abs((error_dt.ramal.dma[8:length(dt.ramal_ma.ts)]/dt.ramal_ma.ts[8:length(dt.ramal_ma.ts)])*100))

akurasi_dt.ramal.dma <- matrix(c(SSE_dt.ramal.dma, MSE_dt.ramal.dma, MAPE_dt.ramal.dma))
row.names(akurasi_dt.ramal.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_dt.ramal.dma) <- c("Akurasi m = 4")
akurasi_dt.ramal.dma
```

Perhitungan akurasi dt.ramal menggunakan nilai MAPE menghasilkan nilai MAPE sebesar 18.92 sehingga dikategorikan baik. Selanjutnya, perhitungan akurasi dilakukan pada dt.uji.

#### 5.4.5 Akurasi data uji

```{r}
#Menghitung nilai keakuratan dt.uji
error_dt.uji.dma = dt.uji_ma.ts-data.gab2[97:120,6]
SSE_dt.uji.dma = sum(error_dt.uji.dma^2)
MSE_dt.uji.dma = mean(error_dt.uji.dma^2)
MAPE_dt.uji.dma = mean(abs((error_dt.uji.dma/dt.uji_ma.ts*100)))

akurasi_dt.uji.dma <- matrix(c(SSE_dt.uji.dma, MSE_dt.uji.dma, MAPE_dt.uji.dma))
row.names(akurasi_dt.uji.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_dt.uji.dma) <- c("Akurasi m = 4")
akurasi_dt.uji.dma
```

Perhitungan akurasi menggunakan dt.uji menghasilkan nilai MAPE yang besar yakni 373.91, sehingga nilai akurasi ini tidak baik.

#### 5.4.6 Kesimpulan dari DMA

```{r}
library(kableExtra)
tabelSMA<-cbind(MAPE_dt.ramal.dma,MAPE_dt.uji.dma)
kable(tabelSMA,caption="Tabel Akurasi Metode DMA")
```

Pada dt.ramal maupun dt.uji, metode **SMA lebih baik dibandingkan** dengan menggunakan metode **DMA**. Hal tersebut dapat dilihat dari nilai MAPE yang diberikan oleh pemulusan dengan SMA lebih kecil dibandingkan dengan DMA. Pada DMA nilai MAPE data ramal sebesar **18.92** yang lebih besar daripada nilai MAPE data ramal pada SMA yaitu **15.61**, kemudian untuk MAPE data uji pada DMA didapatkan **373.91** yang juga lebih besar dibandingkan MAPE data uji SMA yaitu **69.76**.

## 6. Single **Exponential Smoothing & Double Exponential Smoothing**

Metode *Exponential Smoothing* adalah metode pemulusan dengan melakukan pembobotan menurun secara eksponensial. Nilai yang lebih baru diberi bobot yang lebih besar dari nilai terdahulu. Terdapat satu atau lebih parameter pemulusan yang ditentukan secara eksplisit, dan hasil pemilihan parameter tersebut akan menentukan bobot yang akan diberikan pada nilai pengamatan. Ada dua macam model, yaitu model tunggal dan ganda.

### 6.1 Pembagian data

Data yang digunakan masih sama dengan pembagian data yang telah dilakukan pada tahapan sebelumnya, yakni 80% untuk data ramal serta 20% untuk data uji.

```{r}
#Membagi forecasting dan testing
forecasting<-dt.set[1:96,]
testing<-dt.set[97:120,]
forecast.ts<-ts(forecasting$`Produksi Karet Kering`)
test.ts<-ts(testing$`Produksi Karet Kering`)
```

### 6.2 Eksplorasi

Eksplorasi dilakukan dengan membuat plot data deret waktu untuk keseluruhan data, data ramal, dan data uji. Hal ini sama dengan hasil yang sebelumnya.

```{r}
#Eksplorasi data, sama serperti sebelumnya
plot(dt.set.ts, col="blueviolet",main="Plot Semua Data")
points(dt.set)

#Plot data ramal
plot(forecast.ts, col = "brown2",main="Plot Data Ramal")
points(forecast.ts)

#Plot data uji
plot(test.ts, col="cyan3", main="Plot Data Uji")
points(test.ts)

#Dengan package GGPLOT
library(ggplot2)
ggplot() + 
  geom_line(data = forecasting, aes(x = Periode, y = `Produksi Karet Kering`, col = "Data Ramal")) +
  geom_line(data = testing, aes(x = Periode, y = `Produksi Karet Kering`, col = "Data Uji")) +
  labs(x = "Periode Waktu", y = "Produksi Karet Kering", color = "Legend") +
  scale_colour_manual(name="Keterangan:", breaks = c("Data Ramal", "Data Uji"),
                      values = c("cyan3", "brown2")) + 
  theme_bw() + theme(legend.position = "bottom",
                     plot.caption = element_text(hjust=0.5, size=12))
```

### 6.3 SES

#### 6.3.1 Penjelasan SES

Single Exponential Smoothing merupakan metode pemulusan yang tepat digunakan untuk data dengan **pola stasioner atau konstan**.

Nilai pemulusan pada periode ke-t didapat dari persamaan:$$
\tilde{y}_T=\lambda y_t+(1-\lambda)\tilde{y}_{T-1}
$$

Nilai parameter $\lambda$ adalah nilai antara 0 dan 1.

Nilai pemulusan periode ke-t bertindak sebagai nilai ramalan pada periode ke-$(T+\tau)$.

$$ \tilde{y}_{T+\tau}(T)=\tilde{y}_T $$

Pemulusan dengan metode SES dapat dilakukan dengan dua fungsi dari *packages* berbeda, yaitu (1) fungsi `ses()` dari *packages* `forecast` dan (2) fungsi `HoltWinters` dari *packages* `stats` .

#### 6.3.2 Pemulusan SES dengan fungsi, holt winter, dan menggunakan autoplot

Dengan menggunakan h=24 serta alpha =0.2 serta 0.7.

```{r}
#Dengan cara fungsi SES
ses.1 <- ses(forecast.ts, h = 24, alpha = 0.2)
plot(ses.1)
ses.1

ses.2<- ses(forecast.ts, h = 24, alpha = 0.7)
plot(ses.2)
ses.2
```

Untuk mendapatkan gambar hasil pemulusan pada data forecast dengan fungsi `ses()` , perlu digunakan fungsi `autoplot()` dan `autolayer()` dari *library packages* `ggplot2` .

```{r}
autoplot(ses.1) +
  autolayer(fitted(ses.1), series="Fitted") +
  ylab("Produksi Karet Kering") + xlab("Periode")

autoplot(ses.2) +
  autolayer(fitted(ses.2), series="Fitted") +
  ylab("Produksi Karet Kering") + xlab("Periode")
```

Pada fungsi `ses()` , terdapat beberapa argumen yang umum digunakan, yaitu nilai `y` , `gamma` , `beta` , `alpha` , dan `h` .

Nilai `y` adalah nilai data deret waktu, `gamma` adalah parameter pemulusan untuk komponen musiman, `beta` adalah parameter pemulusan untuk tren, dan `alpha` adalah parameter pemulusan untuk stasioner, serta `h` adalah banyaknya periode yang akan diramalkan.

Kasus di atas merupakan contoh inisialisasi nilai parameter λ dengan nilai `alpha` 0,2 dan 0,7 dan banyak periode data yang akan diramalkan adalah sebanyak 24 periode. Selanjutnya akan digunakan fungsi `HoltWinters()` dengan nilai inisialisasi parameter dan panjang periode peramalan yang sama dengan fungsi `ses()` .

```{r}
#Dengan fungsi Holtwinter (cara kedua)
#alpha = 0.2
ses1<- HoltWinters(forecast.ts, gamma = FALSE, beta = FALSE, alpha = 0.2)
plot(ses1)
#Ramalan
ramalan1<- forecast(ses1, h=24)
ramalan1

#alpha = 0.7
ses2<- HoltWinters(forecast.ts, gamma = FALSE, beta = FALSE, alpha = 0.7)
plot(ses2)
#Ramalan
ramalan2<- forecast(ses2, h=24)
ramalan2
```

Fungsi `HoltWinters` memiliki argumen yang sama dengan fungsi `ses()` . Argumen-argumen kedua fungsi dapat dilihat lebih lanjut dengan `?ses()` atau `?HoltWinters` .

Nilai parameter $\alpha$ dari kedua fungsi dapat dioptimalkan menyesuaikan dari *error*-nya paling minimumnya. Caranya adalah dengan membuat parameter $\alpha$ = `NULL` .

#### 6.3.3 Pemulusan ses dengan optimum fungsi, holt winter, serta plot

```{r}
#SES
ses.opt <- ses(forecast.ts, h = 24, alpha = NULL)
plot(ses.opt)
ses.opt

#Lamda Optimum Holt Winter
sesopt<- HoltWinters(forecast.ts, gamma = FALSE, beta = FALSE,alpha = NULL)
sesopt

plot(sesopt)

#Ramalan
ramalanopt<- forecast(sesopt, h=24)
ramalanopt
```

Setelah dilakukan peramalan, akan dilakukan perhitungan keakuratan hasil peramalan. Perhitungan akurasi ini dilakukan baik pada data ramal dan data uji.

#### 6.3.4 Akurasi data ramal

```{r}
#Keakuratan Metode -> pada data forecast/ramal
SSE1<-ses1$SSE
MSE1<-ses1$SSE/length(forecast.ts)
RMSE1<-sqrt(MSE1)

akurasi1 <- matrix(c(SSE1,MSE1,RMSE1))
row.names(akurasi1)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1) <- c("Akurasi lamda=0.2")
akurasi1

SSE2<-ses2$SSE
MSE2<-ses2$SSE/length(forecast.ts)
RMSE2<-sqrt(MSE2)

akurasi2 <- matrix(c(SSE2,MSE2,RMSE2))
row.names(akurasi2)<- c("SSE", "MSE", "RMSE")
colnames(akurasi2) <- c("Akurasi lamda=0.7")
akurasi2
```

Diperoleh SSE sebesar 10203.62, MSE 106.29, dan RMSE 10.31 untuk lamda = 0.2, SSE sebesar 8657.87, MSE 90.19, dan RMSE 9.50 untuk lamda = 0.7.

```{r}
#Cara Manual (lamda=0.2)
fitted1<-ramalan1$fitted
sisaan1<-ramalan1$residuals
head(sisaan1)

resid1<-forecasting$`Produksi Karet Kering`-ramalan1$fitted
head(resid1)
SSE.1=sum(sisaan1[2:length(forecast.ts)]^2)
SSE.1

MSE.1 = SSE.1/length(forecast.ts)
MSE.1

MAPE.1 = sum(abs(sisaan1[2:length(forecast.ts)]/forecast.ts[2:length(forecast.ts)])*
               100)/length(forecast.ts)
MAPE.1

akurasi.1 <- matrix(c(SSE.1,MSE.1,MAPE.1))
row.names(akurasi.1)<- c("SSE", "MSE", "MAPE")
colnames(akurasi.1) <- c("Akurasi lamda=0.2")
akurasi.1

#Cara Manual (lamda=0.7)
fitted2<-ramalan2$fitted
sisaan2<-ramalan2$residuals
head(sisaan2)

resid2<-forecasting$`Produksi Karet Kering`-ramalan2$fitted
head(resid2)

SSE.2=sum(sisaan2[2:length(forecast.ts)]^2)
SSE.2

MSE.2 = SSE.2/length(forecast.ts)
MSE.2

MAPE.2 = sum(abs(sisaan2[2:length(forecast.ts)]/forecast.ts[2:length(forecast.ts)])*
               100)/length(forecast.ts)
MAPE.2

akurasi.2 <- matrix(c(SSE.2,MSE.2,MAPE.2))
row.names(akurasi.2)<- c("SSE", "MSE", "MAPE")
colnames(akurasi.2) <- c("Akurasi lamda=0.7")
akurasi.2
```

Berdasarkan nilai SSE, MSE, RMSE, dan MAPE di antara kedua parameter, nilai parameter $\lambda=0,7$ menghasilkan akurasi yang lebih baik dibandingkan $\lambda=0,2$. Hal ini dilihat dari nilai masing-masing ukuran akurasi yang lebih kecil. Berdasarkan nilai MAPE-nya, hasil ini dapat dikategorikan sebagai peramalan yang sangat baik. MAPE $\lambda=0,2$ dan $\lambda=0,7$ secara berturut-turut sebesar 14.43 dan 12.24.

#### 6.3.5 Akurasi data uji

Akurasi data uji dapat dihitung dengan cara yang hampir sama dengan perhitungan akurasi data latih.

```{r}
selisih1<-ramalan1$mean-testing$`Produksi Karet Kering`
SSEtesting1<-sum(selisih1^2)
MSEtesting1<-SSEtesting1/length(testing)

selisih2<-ramalan2$mean-testing$`Produksi Karet Kering`
SSEtesting2<-sum(selisih2^2)
MSEtesting2<-SSEtesting2/length(testing)

selisihopt<-ramalanopt$mean-testing$`Produksi Karet Kering`
SSEtestingopt<-sum(selisihopt^2)
MSEtestingopt<-SSEtestingopt/length(testing)

akurasitesting1 <- matrix(c(SSEtesting1,SSEtesting2,SSEtestingopt))
row.names(akurasitesting1)<- c("SSE1", "SSE2", "SSEopt")
akurasitesting1

akurasitesting2 <- matrix(c(MSEtesting1,MSEtesting2,MSEtestingopt))
row.names(akurasitesting2)<- c("MSE1", "MSE2", "MSEopt")
akurasitesting2
```

Selain dengan cara di atas, perhitungan nilai akurasi dapat menggunakan fungsi `accuracy()` dari *package* `forecast` . Penggunaannya yaitu dengan menuliskan `accuracy(hasil ramalan, kondisi aktual)` .

```{r}
#Cara alternatif
accuracy(ramalanopt,testing$`Produksi Karet Kering`)
```

Karena memiliki MAPE yang cukup besar untuk ramalan optimum (untuk training 12.34 dan testing 74.98), sehingga memiliki tingkat akurasi yang belum baik. Berikutnya akan dicoba metode pemulusan dengan DES.

Oleh karena itu, diperoleh untuk lamda 0.2 dengan akurasi data ramal = 14.43 (MAPE) dan akurasi data uji sebesar = 9374.69 (SSE). Untuk lamda 0.7 diperoleh akurasi data ramal = 12.24 (MAPE) dan akurasi data uji sebesar = 26385.47 (SSE). Sedangkan untuk akurasi dengan lamda optimum diperoleh akurasi data ramal = 12.34 (MAPE) dan akurasi data latih = 74.98 (MAPE).

### 6.4 DES

#### 6.4.1 Penjelasan pemulusan DES

Metode pemulusan *Double Exponential Smoothing* (DES) digunakan untuk data yang memiliki **pola tren**. Metode DES adalah metode semacam SES, hanya saja dilakukan dua kali, yaitu pertama untuk tahapan 'level' dan kedua untuk tahapan 'tren'. Pemulusan menggunakan metode ini akan menghasilkan peramalan tidak konstan untuk periode berikutnya.

Pemulusan dengan metode DES kali ini akan menggunakan fungsi `HoltWinters()` . Jika sebelumnya nilai argumen `beta` dibuat `FALSE` , kali ini argumen tersebut akan diinisialisasi bersamaan dengan nilai `alpha` .

#### 6.4.2 Melakukan pemulusan metode DES serta plotnya

Menggunakan parameter lamda=0.2, gamma=0.2 serta lamda=0.6, gamma=0.3.

```{r}
#Lamda=0.2 dan gamma=0.2
des.1<- HoltWinters(forecast.ts, gamma = FALSE, beta = 0.2, alpha = 0.2)
plot(des.1)
#Ramalan
ramalandes1<- forecast(des.1, h=24)
ramalandes1

#Lamda=0.6 dan gamma=0.3
des.2<- HoltWinters(forecast.ts, gamma = FALSE, beta = 0.3, alpha = 0.6)
plot(des.2)
#Ramalan
ramalandes2<- forecast(des.2, h=24)
ramalandes2
```

Selanjutnya jika ingin membandingkan plot data ramal dan data uji adalah sebagai berikut.

```{r}
#Visually evaluate the prediction
plot(dt.set.ts)
lines(des.1$fitted[,1], lty=2, col="blue")
lines(ramalandes1$mean, col="red")
```

#### 6.4.3 Metode pemulusan DES optimum

Untuk mendapatkan nilai parameter optimum dari DES, argumen `alpha` dan `beta` dapat dibuat `NULL` seperti berikut.

```{r}
#Lamda dan gamma optimum
des.opt<- HoltWinters(forecast.ts, gamma = FALSE)
des.opt
plot(des.opt)

#Ramalan
ramalandesopt<- forecast(des.opt, h=24)
ramalandesopt
```

Selanjutnya akan dilakukan perhitungan akurasi pada data latih maupun data uji dengan ukuran akurasi SSE, MSE dan MAPE.

#### 6.4.4 Akurasi data ramal

```{r}
#Akurasi data ramal
ssedes.forecast1<-des.1$SSE
msedes.forecast1<-ssedes.forecast1/length(forecast.ts)
sisaandes1<-ramalandes1$residuals
head(sisaandes1)

mapedes.forecast1 <- sum(abs(sisaandes1[3:length(forecast.ts)]/forecast.ts[3:length(forecast.ts)])
                      *100)/length(forecast.ts)

akurasides.1 <- matrix(c(ssedes.forecast1,msedes.forecast1,mapedes.forecast1))
row.names(akurasides.1)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.1) <- c("Akurasi lamda=0.2 dan gamma=0.2")
akurasides.1
```

Diperoleh nilai MAPE sebesar 16.78 untuk metode DES dengan lamda=0.2 dan gamma=0.2.

```{r}
ssedes.forecast2<-des.2$SSE
msedes.forecast2<-ssedes.forecast2/length(forecast.ts)
sisaandes2<-ramalandes2$residuals
head(sisaandes2)

mapedes.forecast2 <- sum(abs(sisaandes2[3:length(forecast.ts)]/forecast.ts[3:length(forecast.ts)])
                      *100)/length(forecast.ts)

akurasides.2 <- matrix(c(ssedes.forecast2,msedes.forecast2,mapedes.forecast2))
row.names(akurasides.2)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.2) <- c("Akurasi lamda=0.6 dan gamma=0.3")
akurasides.2
```

Diperoleh nilai MAPE sebesar 13.62 untuk lamda=0.6 dan gamma=0.3. Hasil dari akurasi dari data forecasting didapatkan pada skenario kedua yakni lamda=0.6 dan gamma=0.3 memiliki hasil yang lebih baik. Namun untuk kedua skenario dapat dikategorikan peramalan yang baik berdasarkan nilai MAPE-nya.

#### 6.4.5 Akurasi data uji

```{r}
#Akurasi data uji
selisihdes1<-ramalandes1$mean-testing$`Produksi Karet Kering`
selisihdes1

SSEtestingdes1<-sum(selisihdes1^2)
MSEtestingdes1<-SSEtestingdes1/length(testing$`Produksi Karet Kering`)
MAPEtestingdes1<-sum(abs(selisihdes1/testing$`Produksi Karet Kering`)*100)/length(testing$`Produksi Karet Kering`)

selisihdes2<-ramalandes2$mean-testing$`Produksi Karet Kering`
selisihdes2

SSEtestingdes2<-sum(selisihdes2^2)
MSEtestingdes2<-SSEtestingdes2/length(testing$`Produksi Karet Kering`)
MAPEtestingdes2<-sum(abs(selisihdes2/testing$`Produksi Karet Kering`)*100)/length(testing$`Produksi Karet Kering`)

selisihdesopt<-ramalandesopt$mean-testing$`Produksi Karet Kering`
selisihdesopt

SSEtestingdesopt<-sum(selisihdesopt^2)
MSEtestingdesopt<-SSEtestingdesopt/length(testing$`Produksi Karet Kering`)
MAPEtestingdesopt<-sum(abs(selisihdesopt/testing$`Produksi Karet Kering`)*100)/length(testing$`Produksi Karet Kering`)

akurasitestingdes <-
  matrix(c(SSEtestingdes1,MSEtestingdes1,MAPEtestingdes1,SSEtestingdes2,MSEtestingdes2,
           MAPEtestingdes2,SSEtestingdesopt,MSEtestingdesopt,MAPEtestingdesopt),
         nrow=3,ncol=3)
row.names(akurasitestingdes)<- c("SSE", "MSE", "MAPE")
colnames(akurasitestingdes) <- c("des ske1","des ske2","des opt")
akurasitestingdes

```

Didapakan nilai MAPEnya secara berturut-turut sebesar 114.20, 256.14, dan 118.65 (optimum).

### 6.5 Perbandingan SES dan DES

```{r}
MSEfull <-
  matrix(c(MSEtesting1,MSEtesting2,MSEtestingopt,MSEtestingdes1,MSEtestingdes2,
           MSEtestingdesopt),nrow=3,ncol=2)
row.names(MSEfull)<- c("ske 1", "ske 2", "ske opt")
colnames(MSEfull) <- c("ses","des")
MSEfull
```

Kedua metode dapat dibandingkan dengan menggunakan ukuran akurasi yang sama. Contoh di atas adalah perbandingan kedua metode dengan ukuran akurasi MSE. Hasilnya didapatkan metode **DES lebih baik** dibandingkan **metode SES** dilihat dari MSE yang lebih kecil nilainya. Hal ini sesuai sebab metode pemulusan DES lebih baik digunakan untuk data yang **trend (bukan stasioner/konstan)**.

## 7. Pemulusan Data Musiman

### 7.1 Pembagian data

Dikarenakan data yang digunakan masih sama, maka sama seperti sebelumnya data akan dibagi dengan cara yang sama. Untuk frequency dicoba menggunakan nilai 3 serta nilai 11, sebab dilihat dari pola datanya membentuk pola yang mirip setiap 3 bulan, maupun 11 bulan.

```{r}
#Membagi forecasting dan testing
forecasting<-dt.set[1:96,2]
testing<-dt.set[97:120,2]
forecast1.ts<-ts(forecasting, frequency = 3)
test1.ts<-ts(testing, frequency = 3)
forecast2.ts<-ts(forecasting,frequency=11)
test2.ts<-ts(testing, frequency = 11)
```

### 7.2 Eksplorasi

Sama seperti sebelumnya, dilakukan eksplorasi dengan plot deret waktu, tentunya akan menghasilkan hasil yang serupa.

```{r}
#Membuat plot time series
plot(dt.set.ts, col="red",main="Plot Semua Data")
points(dt.set.ts)

#frequency=3
plot(forecast1.ts, col="blue",main="Plot Data Ramal")
points(forecast1.ts)
plot(test1.ts, col="green",main="Plot data Uji")
points(test1.ts)

#frequency=7
plot(forecast2.ts, col="orange",main="Plot Data Ramal")
points(forecast2.ts)
plot(test2.ts, col="pink",main="Plot data Uji")
points(test2.ts)
```

Metode Holt-Winter untuk peramalan data musiman menggunakan tiga persamaan pemulusan yang terdiri atas persamaan untuk level $(L_t)$ , trend $(B_t)$ , dan komponen seasonal / musiman $(S_t)$ dengan parameter pemulusan berupa $\alpha$, $\beta$, dan $\gamma$. Metode Holt-Winter musiman terbagi menjadi dua, yaitu metode aditif dan metode multiplikatif.

Pemulusan data musiman dengan metode Winter dilakukan menggunakan fungsi `HoltWinters()` dengan memasukkan argumen tambahan, yaitu `gamma()` dan `seasonal()` . Arguman `seasonal()` diinisialisasi menyesuaikan jenis musiman, aditif atau multiplikatif.

### 7.3 Winter Aditif

#### 7.3.1 Pemulusan winter aditif

Perhitungan dengan model aditif dilakukan jika plot data asli menunjukkan fluktuasi musiman yang relatif stabil (konstan).

```{r}
#Pemulusan dengan winter aditif (frequency 3)
winter1f3 <- HoltWinters(forecast1.ts,alpha=0.2,beta=0.1,gamma=0.1,seasonal = "additive")
winter1f3$fitted
xhat1f3 <- winter1f3$fitted[,2]

winter1f3.opt<- HoltWinters(forecast1.ts, alpha= NULL,  beta = NULL, gamma = NULL, seasonal = "additive")
winter1f3.opt
winter1f3.opt$fitted
xhat1f3.opt <- winter1f3.opt$fitted[,2]

#Pemulisan dengan winter aditif (frequency 11)
winter1f11 <- HoltWinters(forecast2.ts,alpha=0.2,beta=0.1,gamma=0.1,seasonal = "additive")
winter1f11$fitted
xhat1f11 <- winter1f11$fitted[,2]

winter1f11.opt<- HoltWinters(forecast2.ts, alpha= NULL,  beta = NULL, gamma = NULL, seasonal = "additive")
winter1f11.opt
winter1f11.opt$fitted
xhat1f11.opt <- winter1f11.opt$fitted[,2]
```

Untuk peramalan digunakan cara berikut, dengan n.ahead adalah nilai data yang akan diramal yaitu sejumlah 24 periode.

```{r}
#Forecast
forecast1f3 <- predict(winter1f3, n.ahead = 24)
forecast1f3.opt <- predict(winter1f3.opt, n.ahead = 24)

forecast1f11 <- predict(winter1f11, n.ahead = 24)
forecast1f11.opt <- predict(winter1f11.opt, n.ahead = 24)
```

#### 7.3.2 Membuat plot

Membuat plot deret waktu.

```{r}
#Plot time series (untuk frequency=3)
plot(forecast1.ts,main="Winter 0.2;0.1;0.1",type="l",col="black",
     xlim=c(1,12),pch=12)
lines(xhat1f3,type="l",col="red")
lines(xhat1f3.opt,type="l",col="blue")
lines(forecast1f3,type="l",col="red")
lines(forecast1f3.opt,type="l",col="blue")
legend("topleft",c("Actual Data",expression(paste(winter1f3)),
                   expression(paste(winter1f3.opt))),cex=0.5,
       col=c("black","red","blue"),lty=1)

#Plot time series (untuk frequency=11)
plot(forecast2.ts,main="Winter 0.2;0.1;0.1",type="l",col="black",
     xlim=c(1,12),pch=12)
lines(xhat1f11,type="l",col="red")
lines(xhat1f11.opt,type="l",col="blue")
lines(forecast1f11,type="l",col="red")
lines(forecast1f11.opt,type="l",col="blue")
legend("topleft",c("Actual Data",expression(paste(winter1f11)),
                   expression(paste(winter1f11.opt))),cex=0.5,
       col=c("black","red","blue"),lty=1)
```

#### 7.3.3 Akurasi data ramal

```{r}
#Akurasi data ramal (frequency=3)
SSE1f3<-winter1f3$SSE
MSE1f3<-winter1f3$SSE/length(forecast1.ts)
RMSE1f3<-sqrt(MSE1)
akurasi1f3 <- matrix(c(SSE1f3,MSE1f3,RMSE1f3))
row.names(akurasi1f3)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1f3) <- c("Akurasi frequency = 3")
akurasi1f3

#Akurasi data ramal (frequency=7)
SSE1f11<-winter1f11$SSE
MSE1f11<-winter1f11$SSE/length(forecast2.ts)
RMSE1f11<-sqrt(MSE1)
akurasi1f11 <- matrix(c(SSE1f11,MSE1f11,RMSE1f11))
row.names(akurasi1f11)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1f11) <- c("Akurasi frequency = 11")
akurasi1f11
```

Didapatkan untuk frequency 3, dengan SSE 10790.34, MSE 112.40, RMSE 10.31, kemudian untuk frequency = 7, dengan SSE 12560.50, MSE 130.84, dan RMSE 10.3096

```{r}
#Akurasi data ramal dengan winter aditif dengan parameter optimum
#frequency=3
SSE1f3.opt<-winter1f3.opt$SSE
MSE1f3.opt<-winter1f3.opt$SSE/length(forecast1.ts)
RMSE1f3.opt<-sqrt(MSE1f3.opt)
akurasi1f3.opt <- matrix(c(SSE1f3.opt,MSE1f3.opt,RMSE1f3.opt))
row.names(akurasi1f3.opt)<- c("SSE1f3.opt", "MSE1f3.opt", "RMSE1f3.opt")
colnames(akurasi1f3.opt) <- c("Akurasi")
akurasi1f3.opt

#frequency=7
SSE1f11.opt<-winter1f11.opt$SSE
MSE1f11.opt<-winter1f11.opt$SSE/length(forecast2.ts)
RMSE1f11.opt<-sqrt(MSE1f11.opt)
akurasi1f11.opt <- matrix(c(SSE1f11.opt,MSE1f11.opt,RMSE1f11.opt))
row.names(akurasi1f11.opt)<- c("SSE1f11.opt", "MSE1f11.opt", "RMSE1f11.opt")
colnames(akurasi1f11.opt) <- c("Akurasi")
akurasi1f11.opt
```

Maka hasil akurasi tersebut akan digabungkan dalam sebuah tabel agar mempermudah untuk membandingkannya.

```{r}
akurasi1f3.forecast = data.frame(Model_Winter = c("Winter 1f3","Winter1 optimalf3"),
                            Nilai_SSE=c(SSE1f3,SSE1f3.opt),
                            Nilai_MSE=c(MSE1f3,MSE1f3.opt),Nilai_RMSE=c(RMSE1f3,RMSE1f3.opt))
akurasi1f3.forecast

akurasi1f11.forecast = data.frame(Model_Winter = c("Winter 1f11","Winter1 optimalf11"),
                            Nilai_SSE=c(SSE1f11,SSE1f11.opt),
                            Nilai_MSE=c(MSE1f11,MSE1f11.opt),Nilai_RMSE=c(RMSE1f11,RMSE1f11.opt))
akurasi1f11.forecast
```

#### 7.3.4 Akurasi data uji

```{r}
#Akurasi Data Testing
forecast1f3<-data.frame(forecast1f3)
testingf3.ts<-data.frame(test.ts)
selisih1f3<-forecast1f3-testingf3.ts
SSEtesting1f3<-sum(selisih1f3^2)
MSEtesting1f3<-SSEtesting1f3/length(testingf3.ts)

forecast1f3.opt<-data.frame(forecast1f3.opt)
selisih1f3.opt<-forecast1f3.opt-testingf3.ts
SSEtesting1f3.opt<-sum(selisih1f3.opt^2)
MSEtesting1f3.opt<-SSEtesting1f3.opt/length(testingf3.ts)

forecast1f11<-data.frame(forecast1f11)
testingf11.ts<-data.frame(test2.ts)
selisih1f11<-forecast1f11-testingf11.ts
SSEtesting1f11<-sum(selisih1f11^2)
MSEtesting1f11<-SSEtesting1f11/length(testingf11.ts)

forecast1f11.opt<-data.frame(forecast1f11.opt)
selisih1f11.opt<-forecast1f11.opt-testingf11.ts
SSEtesting1f11.opt<-sum(selisih1f11.opt^2)
MSEtesting1f11.opt<-SSEtesting1f11.opt/length(testingf11.ts)

cat("SSE frequency 3:" ,SSEtesting1f3, "\n")
cat("SSE optimum frequency 3:", SSEtesting1f3.opt, "\n")
cat("SSE frequency 11:" ,SSEtesting1f11, "\n")
cat("SSE optimum frequency 11:", SSEtesting1f11.opt, "\n")
```

Karena berdasarkan plot, hasil yang diperoleh paling serupa dengan frequency 11, maka walaupun akurasi untuk data ramal/forecast dan ujinya lebih baik di frequency 3, tetap digunakan frequency 11.

### 7.4 Winter Multiplikatif

Mengembalikan penamaan

```{r}
forecast.ts = forecast2.ts
test.ts = test2.ts
```

#### 7.4.1 Pemulusan dengan winter multiplikastif

Model ini baik digunakan jika plot data asli menunjukkan fluktuasi musiman yang bervariasi.

```{r}
#Pemulusan dengan winter multiplikatif 
winter2 <- HoltWinters(forecast.ts,alpha=0.2,beta=0.1,gamma=0.3,seasonal = "multiplicative")
winter2$fitted
xhat2 <- winter2$fitted[,2]

#Winter multiplikatif parameter optimum
winter2.opt<- HoltWinters(forecast.ts, alpha= NULL,  beta = NULL, gamma = NULL, seasonal = "multiplicative")
winter2.opt$fitted
xhat2.opt <- winter2.opt$fitted[,2]
```

Peramalan, dengan periode yang ingin diramal sebanyak 24 periode kedepan, sehingga n.ahead=24.

```{r}
#Forecast
forecast2 <- predict(winter2, n.ahead = 24)
forecast2.opt <- predict(winter2.opt, n.ahead = 24)
```

#### 7.4.2 Plot deret waktu (winter multiplikatif)

```{r}
#Plot time series
plot(forecast.ts,main="Winter 0.2;0.1;0.1",type="l",col="black",
     xlim=c(1,12),pch=12)
lines(xhat2,type="l",col="red")
lines(xhat2.opt,type="l",col="blue")
lines(forecast2,type="l",col="red")
lines(forecast2.opt,type="l",col="blue")
legend("topleft",c("Actual Data",expression(paste(winter2)),
                   expression(paste(winter2.opt))),cex=0.5,
       col=c("black","red","blue"),lty=1)
```

#### 7.4.3 Akurasi data ramal

```{r}
#Akurasi data training
SSE2<-winter2$SSE
MSE2<-winter2$SSE/length(forecast.ts)
RMSE2<-sqrt(MSE2)
akurasi1 <- matrix(c(SSE2,MSE2,RMSE2))
row.names(akurasi1)<- c("SSE2", "MSE2", "RMSE2")
colnames(akurasi1) <- c("Akurasi lamda=0.2")
akurasi1
```

Didapatkan hasil SSE sebesar 12217.96, MSE sebesar 127.27, serta RMSE sebesar 11.28.

```{r}
#Akurasi data latih, dengan parameter optimum
SSE2.opt<-winter2.opt$SSE
MSE2.opt<-winter2.opt$SSE/length(forecast.ts)
RMSE2.opt<-sqrt(MSE2.opt)
akurasi1.opt <- matrix(c(SSE2.opt,MSE2.opt,RMSE2.opt))
row.names(akurasi1.opt)<- c("SSE2.opt", "MSE2.opt", "RMSE2.opt")
colnames(akurasi1.opt) <- c("Akurasi")
akurasi1.opt
```

Didapatkan hasil SSE sebesar 11028.71, MSE sebesar 114.88, serta RMSE sebesar 10.72.

Lalu dibuat sebuah tabel untuk melihat perbandingan antara winter multiplikatif dengan yang menggunakan parameter optimum maupun bukan yang optimum.

```{r}
akurasi2.forecast = data.frame(Model_Winter = c("Winter 1","winter2 optimal"),
                            Nilai_SSE=c(SSE2,SSE2.opt),
                            Nilai_MSE=c(MSE2,MSE2.opt),Nilai_RMSE=c(RMSE2,RMSE2.opt))
akurasi2.forecast
```

#### 7.4.4 Akurasi Data Uji (Winter Multiplikatif)

```{r}
#Akurasi Data Testing
forecast2<-data.frame(forecast2)
testing.ts<-data.frame(test.ts)
selisih2<-forecast2-testing.ts
SSEtesting2<-sum(selisih2^2)
MSEtesting2<-SSEtesting2/length(testing.ts)

forecast2.opt<-data.frame(forecast2.opt)
selisih2.opt<-forecast2.opt-testing.ts
SSEtesting2.opt<-sum(selisih2.opt^2)
MSEtesting2.opt<-SSEtesting2.opt/length(testing.ts)

SSEtesting2
SSEtesting2.opt
```

## 8. Keputusan Metode Pumulusan Terbaik

#### 8.1 SMA atau DMA?

Pada langkah metode Single Moving Average (SMA) dan Double Moving Average (DMA) telah diketahui metode pemulusan dengan **Single Moving Average (SMA) lebih baik** dibandingkan dengan DMA. Hal ini diakibatkan nilai MAPE yang diberikan oleh pemulusan dengan SMA lebih kecil dibandingkan dengan DMA.

#### 8.2 SES **atau DES?**

Metode **Double Exponential Smoothing (DES) lebih baik** dibandingkan metode SES dilihat dari MSE yang lebih kecil nilainya. Hal ini sesuai sebab metode pemulusan DES lebih baik digunakan untuk data yang trend (bukan stasioner/konstan).

#### 8.3 Winter Aditif atau Multiplikatif?

Sebelumnya dimanfaatkan nilai frequency=11 dengan parameter yang optimum, sehingga untuk winter aditif diperoleh keakuratan data ramal dengan nilai SSE sebesar **11951.95** dengan nilai SSE data uji sebesar **40287.72**. Sedangkan untuk winter multiplikatif diperoleh keakuratan data ramal dengan nilai SSE sebesar **11028.71** dengan nilai SSE data uji **9913.769**. Karena SSE data latih winter multiplikatif \< daripada SSE data latih winter aditif, serta SSE data uji winter multiplikatif juga \< daripada SSE data uji winter aditif maka dapat dikatakan **winter multiplikatif lebih baik** dibandingkan metode pemulusan winter aditif.

**8.4 SMA, DES, atau winter multiplikatif?**

```{r}
#SMA vs DES

#SMA
cat("MAPE data ramal SMA:", MAPE_dt.ramal.sma, "\n")
cat("MAPE data uji SMA:", MAPE_dt.uji.sma, "\n\n")
#DES
cat("MAPE data ramal DES:", mapedes.forecast2, "\n")
cat("MAAPE data uji DES:", MAPEtestingdes2, "\n")
cat("MAPE data ramal optim DES:", MAPEtestingdesopt , "\n\n")

#Diambil yang SMA karena mayoritas akurasi MAPE SMA didapatkan < daripada akurasi MAPE pada DES

#SMA vs winter multiplikatif

#SMA
cat("SSE data ramal SMA:", SSE_dt.ramal.sma, "\n")
cat("SSE data uji SMA:", SSE_dt.uji.sma, "\n\n")

#Winter multiplikatif
cat("SSE data ramal optim winter multi:", SSE2.opt, "\n")
cat("SSE data uji optim winter multi:", SSEtesting2.opt, "\n")
```

Oleh karena itu, untuk data tersebut disarankan menggunakan **metode pemulusan winter multiplikatif.**

## 9. Saran

Terkait data yang digunakan terkategorikan sebagai data yang kurang baik, hal ini disebabkan terlihat adanya dua pola yang berbeda. Maka hal ini mengakibatkan sulitnya menentukan pola sebaran data. Secara garis besar pola data deret waktu ada pola horizontal (konstan), pola musiman, pola siklis, ataupun pola trend. Pada analisis kali ini diasumsikan polanya mengikuti pola trend ataupun musiman dengan pengambilan asumsi berdasarkan eksplorasi data memalui plot time series. Sehingga hal ini mengakibatkan diharuskan mencoba satu persatu dari beragam metode pemulusan yang tersedia.
